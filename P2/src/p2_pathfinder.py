from math import inf, sqrtfrom heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []# list of line segment (src, p1, p2,...., dst)    boxes = []# list of boxes (src_box, b1, b2,..., dst_box)    #path, boxes = a_star(mesh, source_point, destination_point)    path, boxes = a_star(mesh, source_point, destination_point)    BFS(mesh, source_point, destination_point)    return path, boxes#check if point is inside boxdef point_check(box, point):    x, y = point    x1, x2, y1, y2 = box    #if (this) then point is outside of box    if (x < x1 or x > x2 or y < y1 or y > y2):        return False    else:        return True#this return box if point is in boxdef search_for_box(mesh, point):    for box in mesh['boxes']:        if point_check(box, point):            return box#kept this function to test to make sure if path is possibledef BFS(mesh, source_point, destination_point):    Q = []    visited = []    found = False    src_box = search_for_box(mesh, source_point)    dest_box = search_for_box(mesh, destination_point)    Q.append(src_box)    visited.append(src_box)    while Q:        current_box = heappop(Q)        if current_box == dest_box:            found = True            break        #check all adj of src        for adj_box in mesh["adj"][current_box]:            if adj_box not in visited:                Q.append(adj_box)                visited.append(adj_box)    if not found:        print("No Path Found!")    else:        print("Found path with BFS")def get_euclidean_dist(p1, p2):    return sqrt( ((p1[0]-p2[0])**2) + ((p1[1]-p2[1])**2) )#if a path exist this return a dict with two lists# one with line segments, other with boxesdef a_star(mesh, source_point, destination_point):    Q = []    prev = {}    dist = {}    detail_points = {}    path = []# list of line segment (((x,y),(x,y)), .....)    boxes = []# list of boxes (src_box, b1, b2,..., dst_box)    src_box = search_for_box(mesh, source_point)    dest_box = search_for_box(mesh, destination_point)    detail_points[src_box] = source_point    prev[src_box] = None    dist[src_box] = 0    #Taking care of cases where source_point and destination_point are the same    # and if they are in the same box    if source_point == destination_point or src_box == dest_box:        path.append((source_point, destination_point))        boxes.append(src_box)        return path, boxes    heappush(Q, src_box)    while Q:        current_box = heappop(Q)        if current_box == dest_box:            current_box = dest_box            path.append((detail_points[dest_box], destination_point))            while current_box != src_box:                boxes.insert(0, current_box)                path.insert(0, (detail_points[prev[current_box]], detail_points[current_box]))                current_box = prev[current_box]            path.insert(0, (source_point, detail_points[current_box]))            boxes.insert(0, src_box)            return path, boxes        for adj_box in mesh["adj"][current_box]:            #[max(b1x1, b2x1), min(b1x2, b2x2), max(b1y1, b2y1), min(b1y2), b2y2]            #border = (x1, x2, y1, y2) of border edge            border = [max(current_box[0], adj_box[0]), min(current_box[1], adj_box[1]), max(current_box[2], adj_box[2]), min(current_box[3], adj_box[3])]            mid_point = ((border[0] + border[1]) / 2, (border[2] + border[3]) / 2)            dist_left = get_euclidean_dist(detail_points[current_box], (border[0], border[2]))             dist_right = get_euclidean_dist(detail_points[current_box], (border[1], border[3]))            dist_mid = get_euclidean_dist(detail_points[current_box], mid_point)            if (min(dist_left, dist_right, dist_mid) == dist_left):                detail_points[adj_box] = (border[0], border[2])            elif(min(dist_left, dist_right, dist_mid) == dist_right):                detail_points[adj_box] = (border[1], border[3])            else:                detail_points[adj_box] = mid_point            #add distance traveled so far with remaining distance            #dist_so_far + edge_distance + remaining distance            distance = dist[current_box] + get_euclidean_dist(detail_points[adj_box], detail_points[current_box]) + get_euclidean_dist(detail_points[adj_box], destination_point)            if adj_box not in dist or distance < dist[adj_box]:                dist[adj_box] = distance                prev[adj_box] = current_box                heappush(Q, adj_box)    return None, None