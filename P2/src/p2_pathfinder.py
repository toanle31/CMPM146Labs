from math import inf, sqrtfrom heapq import heappop, heappushdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []# list of line segment (src, p1, p2,...., dst)    boxes = []# list of boxes (src_box, b1, b2,..., dst_box)    #path, boxes = a_star(mesh, source_point, destination_point)    path, boxes = a_star(mesh, source_point, destination_point)    #boxes = mesh["boxes"] #debug to see all available boxes    BFS(mesh, source_point, destination_point)    return path, boxes#check if point is inside boxdef point_check(box, point):    x, y = point    x1, x2, y1, y2 = box    #if (this) then point is outside of box    return not (x < x1 or x > x2 or y < y1 or y > y2)#this return box if point is in boxdef search_for_box(mesh, point):    for box in mesh['boxes']:        if point_check(box, point):            return box#kept this function to test to make sure if path is possibledef BFS(mesh, source_point, destination_point):    Q = []    visited = []    found = False    src_box = search_for_box(mesh, source_point)    dest_box = search_for_box(mesh, destination_point)    Q.append(src_box)    visited.append(src_box)    while Q:        current_box = heappop(Q)        if current_box == dest_box:            found = True            break        #check all adj of src        for adj_box in mesh["adj"][current_box]:            if adj_box not in visited:                Q.append(adj_box)                visited.append(adj_box)    if not found:        print("No Path Found!")    else:        print("Found path with BFS")def get_euclidean_dist(p1, p2):    return sqrt( ((p1[0]-p2[0])**2)+((p1[1]-p2[1])**2) )#if a path exist this return a dict with two lists# one with line segments, other with boxesdef a_star(mesh, source_point, destination_point):    Q = []    prev = {}    dist = {}    detail_points = {} # maps box to the point that will be traversed within the box    path = []# list of line segment (((x,y),(x,y)), .....)    boxes = []# list of boxes (src_box, b1, b2,..., dst_box)    src_box = search_for_box(mesh, source_point)    dest_box = search_for_box(mesh, destination_point)    detail_points[src_box] = source_point    Q = [(0, src_box)]    prev[src_box] = None    dist[src_box] = 0    dist_so_far = 0    edge_distance = 0    dist_remaining = 0    #Taking care of cases where source_point and destination_point are the same    # and if they are in the same box    if source_point == destination_point or src_box == dest_box:        path.append((source_point, destination_point))        boxes.append(src_box)        return path, boxes    while Q:        weight, current_box = heappop(Q)        #if a path is found build the two list and return them        if current_box == dest_box:            print("Path found by A*, building lists for return")            current_box = dest_box            path.append((destination_point, detail_points[dest_box]))            while prev[current_box]:                boxes.insert(0, current_box)                path.append((detail_points[prev[current_box]], detail_points[current_box]))                current_box = prev[current_box]            boxes.insert(0, src_box)            return path, boxes        #calculate distance to current_node        if prev[current_box] != None:            dist_so_far += get_euclidean_dist(detail_points[current_box], detail_points[prev[current_box]])        for adj_box in mesh["adj"][current_box]:            #[max(b1x1, b2x1), min(b1x2, b2x2), max(b1y1, b2y1), min(b1y2), b2y2]            #border = (x1, x2, y1, y2) of border edge            border = [max(current_box[0], adj_box[0]), min(current_box[1], adj_box[1]), max(current_box[2], adj_box[2]), min(current_box[3], adj_box[3])]            mid_point = ((border[0] + border[1]) / 2, (border[2] + border[3]) / 2)            dist_left = get_euclidean_dist(detail_points[current_box], (border[0], border[2]))             dist_right = get_euclidean_dist(detail_points[current_box], (border[1], border[3]))            dist_mid = get_euclidean_dist(detail_points[current_box], mid_point)            if min(dist_left, dist_right, dist_mid) == dist_left:                adj_box_point = (border[0], border[2])            elif min(dist_left, dist_right, dist_mid) == dist_right:                adj_box_point = (border[1], border[3])            else:                adj_box_point = mid_point            edge_distance = get_euclidean_dist(adj_box_point, detail_points[current_box])            dist_remaining = get_euclidean_dist(adj_box_point, destination_point)            weight = dist_so_far + edge_distance + dist_remaining            if adj_box not in dist or weight < dist[adj_box]:                dist[adj_box] = weight                prev[adj_box] = current_box                detail_points[adj_box] = adj_box_point                heappush(Q, (weight, adj_box))    print("No Path found by A*")    return None, None